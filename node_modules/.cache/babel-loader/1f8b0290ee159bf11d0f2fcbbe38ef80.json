{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar path = require('path');\n\nvar os = require('os');\n\nvar fs = require('graceful-fs');\n\nvar makeDir = require('make-dir');\n\nvar xdgBasedir = require('xdg-basedir');\n\nvar writeFileAtomic = require('write-file-atomic');\n\nvar dotProp = require('dot-prop');\n\nvar uniqueString = require('unique-string');\n\nvar configDirectory = xdgBasedir.config || path.join(os.tmpdir(), uniqueString());\nvar permissionError = 'You don\\'t have access to this file.';\nvar makeDirOptions = {\n  mode: 448\n};\nvar writeFileOptions = {\n  mode: 384\n};\n\nvar Configstore = /*#__PURE__*/function () {\n  function Configstore(id, defaults) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, Configstore);\n\n    var pathPrefix = options.globalConfigPath ? path.join(id, 'config.json') : path.join('configstore', \"\".concat(id, \".json\"));\n    this.path = options.configPath || path.join(configDirectory, pathPrefix);\n\n    if (defaults) {\n      this.all = _objectSpread(_objectSpread({}, defaults), this.all);\n    }\n  }\n\n  _createClass(Configstore, [{\n    key: \"get\",\n    value: function get(key) {\n      return dotProp.get(this.all, key);\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      var config = this.all;\n\n      if (arguments.length === 1) {\n        for (var _i = 0, _Object$keys = Object.keys(key); _i < _Object$keys.length; _i++) {\n          var k = _Object$keys[_i];\n          dotProp.set(config, k, key[k]);\n        }\n      } else {\n        dotProp.set(config, key, value);\n      }\n\n      this.all = config;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return dotProp.has(this.all, key);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var config = this.all;\n      dotProp.delete(config, key);\n      this.all = config;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.all = {};\n    }\n  }, {\n    key: \"all\",\n    get: function get() {\n      try {\n        return JSON.parse(fs.readFileSync(this.path, 'utf8'));\n      } catch (error) {\n        // Create directory if it doesn't exist\n        if (error.code === 'ENOENT') {\n          return {};\n        } // Improve the message of permission errors\n\n\n        if (error.code === 'EACCES') {\n          error.message = \"\".concat(error.message, \"\\n\").concat(permissionError, \"\\n\");\n        } // Empty the file if it encounters invalid JSON\n\n\n        if (error.name === 'SyntaxError') {\n          writeFileAtomic.sync(this.path, '', writeFileOptions);\n          return {};\n        }\n\n        throw error;\n      }\n    },\n    set: function set(value) {\n      try {\n        // Make sure the folder exists as it could have been deleted in the meantime\n        makeDir.sync(path.dirname(this.path), makeDirOptions);\n        writeFileAtomic.sync(this.path, JSON.stringify(value, undefined, '\\t'), writeFileOptions);\n      } catch (error) {\n        // Improve the message of permission errors\n        if (error.code === 'EACCES') {\n          error.message = \"\".concat(error.message, \"\\n\").concat(permissionError, \"\\n\");\n        }\n\n        throw error;\n      }\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return Object.keys(this.all || {}).length;\n    }\n  }]);\n\n  return Configstore;\n}();\n\nmodule.exports = Configstore;","map":{"version":3,"sources":["D:/medium clone/node_modules/configstore/index.js"],"names":["path","require","os","fs","makeDir","xdgBasedir","writeFileAtomic","dotProp","uniqueString","configDirectory","config","join","tmpdir","permissionError","makeDirOptions","mode","writeFileOptions","Configstore","id","defaults","options","pathPrefix","globalConfigPath","configPath","all","key","get","value","arguments","length","Object","keys","k","set","has","delete","JSON","parse","readFileSync","error","code","message","name","sync","dirname","stringify","undefined","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst path = require('path');\nconst os = require('os');\nconst fs = require('graceful-fs');\nconst makeDir = require('make-dir');\nconst xdgBasedir = require('xdg-basedir');\nconst writeFileAtomic = require('write-file-atomic');\nconst dotProp = require('dot-prop');\nconst uniqueString = require('unique-string');\n\nconst configDirectory = xdgBasedir.config || path.join(os.tmpdir(), uniqueString());\nconst permissionError = 'You don\\'t have access to this file.';\nconst makeDirOptions = {mode: 0o0700};\nconst writeFileOptions = {mode: 0o0600};\n\nclass Configstore {\n\tconstructor(id, defaults, options = {}) {\n\t\tconst pathPrefix = options.globalConfigPath ?\n\t\t\tpath.join(id, 'config.json') :\n\t\t\tpath.join('configstore', `${id}.json`);\n\n\t\tthis.path = options.configPath || path.join(configDirectory, pathPrefix);\n\n\t\tif (defaults) {\n\t\t\tthis.all = {\n\t\t\t\t...defaults,\n\t\t\t\t...this.all\n\t\t\t};\n\t\t}\n\t}\n\n\tget all() {\n\t\ttry {\n\t\t\treturn JSON.parse(fs.readFileSync(this.path, 'utf8'));\n\t\t} catch (error) {\n\t\t\t// Create directory if it doesn't exist\n\t\t\tif (error.code === 'ENOENT') {\n\t\t\t\treturn {};\n\t\t\t}\n\n\t\t\t// Improve the message of permission errors\n\t\t\tif (error.code === 'EACCES') {\n\t\t\t\terror.message = `${error.message}\\n${permissionError}\\n`;\n\t\t\t}\n\n\t\t\t// Empty the file if it encounters invalid JSON\n\t\t\tif (error.name === 'SyntaxError') {\n\t\t\t\twriteFileAtomic.sync(this.path, '', writeFileOptions);\n\t\t\t\treturn {};\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tset all(value) {\n\t\ttry {\n\t\t\t// Make sure the folder exists as it could have been deleted in the meantime\n\t\t\tmakeDir.sync(path.dirname(this.path), makeDirOptions);\n\n\t\t\twriteFileAtomic.sync(this.path, JSON.stringify(value, undefined, '\\t'), writeFileOptions);\n\t\t} catch (error) {\n\t\t\t// Improve the message of permission errors\n\t\t\tif (error.code === 'EACCES') {\n\t\t\t\terror.message = `${error.message}\\n${permissionError}\\n`;\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tget size() {\n\t\treturn Object.keys(this.all || {}).length;\n\t}\n\n\tget(key) {\n\t\treturn dotProp.get(this.all, key);\n\t}\n\n\tset(key, value) {\n\t\tconst config = this.all;\n\n\t\tif (arguments.length === 1) {\n\t\t\tfor (const k of Object.keys(key)) {\n\t\t\t\tdotProp.set(config, k, key[k]);\n\t\t\t}\n\t\t} else {\n\t\t\tdotProp.set(config, key, value);\n\t\t}\n\n\t\tthis.all = config;\n\t}\n\n\thas(key) {\n\t\treturn dotProp.has(this.all, key);\n\t}\n\n\tdelete(key) {\n\t\tconst config = this.all;\n\t\tdotProp.delete(config, key);\n\t\tthis.all = config;\n\t}\n\n\tclear() {\n\t\tthis.all = {};\n\t}\n}\n\nmodule.exports = Configstore;\n"]},"metadata":{},"sourceType":"script"}