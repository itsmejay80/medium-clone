{"ast":null,"code":"\"use strict\"; // Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _inherits = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapNativeSuper\");\n\nvar _slicedToArray = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _objectSpread = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SigningError = exports.URLSigner = exports.PATH_STYLED_HOST = void 0;\n\nvar crypto = require(\"crypto\");\n\nvar dateFormat = require(\"date-and-time\");\n\nvar url = require(\"url\");\n\nvar util_1 = require(\"./util\");\n/*\n * Default signing version for getSignedUrl is 'v2'.\n */\n\n\nvar DEFAULT_SIGNING_VERSION = 'v2';\nvar SEVEN_DAYS = 604800;\n/**\n * @const {string}\n * @private\n */\n\nexports.PATH_STYLED_HOST = 'https://storage.googleapis.com';\n\nvar URLSigner = /*#__PURE__*/function () {\n  function URLSigner(authClient, bucket, file) {\n    _classCallCheck(this, URLSigner);\n\n    this.bucket = bucket;\n    this.file = file;\n    this.authClient = authClient;\n  }\n\n  _createClass(URLSigner, [{\n    key: \"getSignedUrl\",\n    value: function getSignedUrl(cfg) {\n      var _this = this;\n\n      var expiresInSeconds = this.parseExpires(cfg.expires);\n      var method = cfg.method;\n      var customHost; // Default style is `path`.\n\n      var isVirtualHostedStyle = cfg.virtualHostedStyle || false;\n\n      if (cfg.cname) {\n        customHost = cfg.cname;\n      } else if (isVirtualHostedStyle) {\n        customHost = \"https://\".concat(this.bucket.name, \".storage.googleapis.com\");\n      }\n\n      var config = Object.assign({}, cfg, {\n        method: method,\n        expiration: expiresInSeconds,\n        bucket: this.bucket.name,\n        file: this.file ? util_1.encodeURI(this.file.name, false) : undefined\n      });\n\n      if (customHost) {\n        config.cname = customHost;\n      }\n\n      var version = cfg.version || DEFAULT_SIGNING_VERSION;\n      var promise;\n\n      if (version === 'v2') {\n        promise = this.getSignedUrlV2(config);\n      } else if (version === 'v4') {\n        promise = this.getSignedUrlV4(config);\n      } else {\n        throw new Error(\"Invalid signed URL version: \".concat(version, \". Supported versions are 'v2' and 'v4'.\"));\n      }\n\n      return promise.then(function (query) {\n        query = Object.assign(query, cfg.queryParams);\n        var signedUrl = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n        signedUrl.pathname = _this.getResourcePath(!!config.cname, _this.bucket.name, config.file); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        signedUrl.search = util_1.qsStringify(query);\n        return signedUrl.href;\n      });\n    }\n  }, {\n    key: \"getSignedUrlV2\",\n    value: function getSignedUrlV2(config) {\n      var _this2 = this;\n\n      var canonicalHeadersString = this.getCanonicalHeaders(config.extensionHeaders || {});\n      var resourcePath = this.getResourcePath(false, config.bucket, config.file);\n      var blobToSign = [config.method, config.contentMd5 || '', config.contentType || '', config.expiration, canonicalHeadersString + resourcePath].join('\\n');\n\n      var sign = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var authClient, signature, credentials, signingErr;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  authClient = _this2.authClient;\n                  _context.prev = 1;\n                  _context.next = 4;\n                  return authClient.sign(blobToSign);\n\n                case 4:\n                  signature = _context.sent;\n                  _context.next = 7;\n                  return authClient.getCredentials();\n\n                case 7:\n                  credentials = _context.sent;\n                  return _context.abrupt(\"return\", {\n                    GoogleAccessId: credentials.client_email,\n                    Expires: config.expiration,\n                    Signature: signature\n                  });\n\n                case 11:\n                  _context.prev = 11;\n                  _context.t0 = _context[\"catch\"](1);\n                  signingErr = new SigningError(_context.t0.message);\n                  signingErr.stack = _context.t0.stack;\n                  throw signingErr;\n\n                case 16:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[1, 11]]);\n        }));\n\n        return function sign() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      return sign();\n    }\n  }, {\n    key: \"getSignedUrlV4\",\n    value: function getSignedUrlV4(config) {\n      var _this3 = this;\n\n      var now = new Date();\n      var nowInSeconds = Math.floor(now.valueOf() / 1000);\n      var expiresPeriodInSeconds = config.expiration - nowInSeconds; // v4 limit expiration to be 7 days maximum\n\n      if (expiresPeriodInSeconds > SEVEN_DAYS) {\n        throw new Error(\"Max allowed expiration is seven days (\".concat(SEVEN_DAYS, \" seconds).\"));\n      }\n\n      var extensionHeaders = Object.assign({}, config.extensionHeaders);\n      var fqdn = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n      extensionHeaders.host = fqdn.host;\n\n      if (config.contentMd5) {\n        extensionHeaders['content-md5'] = config.contentMd5;\n      }\n\n      if (config.contentType) {\n        extensionHeaders['content-type'] = config.contentType;\n      }\n\n      var contentSha256;\n      var sha256Header = extensionHeaders['x-goog-content-sha256'];\n\n      if (sha256Header) {\n        if (typeof sha256Header !== 'string' || !/[A-Fa-f0-9]{40}/.test(sha256Header)) {\n          throw new Error('The header X-Goog-Content-SHA256 must be a hexadecimal string.');\n        }\n\n        contentSha256 = sha256Header;\n      }\n\n      var signedHeaders = Object.keys(extensionHeaders).map(function (header) {\n        return header.toLowerCase();\n      }).sort().join(';');\n      var extensionHeadersString = this.getCanonicalHeaders(extensionHeaders);\n      var datestamp = dateFormat.format(now, 'YYYYMMDD', true);\n      var credentialScope = \"\".concat(datestamp, \"/auto/storage/goog4_request\");\n\n      var sign = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n          var credentials, credential, dateISO, queryParams, canonicalQueryParams, canonicalRequest, hash, blobToSign, signature, signatureHex, signedQuery, signingErr;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return _this3.authClient.getCredentials();\n\n                case 2:\n                  credentials = _context2.sent;\n                  credential = \"\".concat(credentials.client_email, \"/\").concat(credentialScope);\n                  dateISO = dateFormat.format(now, 'YYYYMMDD[T]HHmmss[Z]', true);\n                  queryParams = _objectSpread({\n                    'X-Goog-Algorithm': 'GOOG4-RSA-SHA256',\n                    'X-Goog-Credential': credential,\n                    'X-Goog-Date': dateISO,\n                    'X-Goog-Expires': expiresPeriodInSeconds.toString(10),\n                    'X-Goog-SignedHeaders': signedHeaders\n                  }, config.queryParams || {}); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n                  canonicalQueryParams = _this3.getCanonicalQueryParams(queryParams);\n                  canonicalRequest = _this3.getCanonicalRequest(config.method, _this3.getResourcePath(!!config.cname, config.bucket, config.file), canonicalQueryParams, extensionHeadersString, signedHeaders, contentSha256);\n                  hash = crypto.createHash('sha256').update(canonicalRequest).digest('hex');\n                  blobToSign = ['GOOG4-RSA-SHA256', dateISO, credentialScope, hash].join('\\n');\n                  _context2.prev = 10;\n                  _context2.next = 13;\n                  return _this3.authClient.sign(blobToSign);\n\n                case 13:\n                  signature = _context2.sent;\n                  signatureHex = Buffer.from(signature, 'base64').toString('hex');\n                  signedQuery = Object.assign({}, queryParams, {\n                    'X-Goog-Signature': signatureHex\n                  });\n                  return _context2.abrupt(\"return\", signedQuery);\n\n                case 19:\n                  _context2.prev = 19;\n                  _context2.t0 = _context2[\"catch\"](10);\n                  signingErr = new SigningError(_context2.t0.message);\n                  signingErr.stack = _context2.t0.stack;\n                  throw signingErr;\n\n                case 24:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, null, [[10, 19]]);\n        }));\n\n        return function sign() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      return sign();\n    }\n    /**\n     * Create canonical headers for signing v4 url.\n     *\n     * The canonical headers for v4-signing a request demands header names are\n     * first lowercased, followed by sorting the header names.\n     * Then, construct the canonical headers part of the request:\n     *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n     *  ..\n     *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n     *\n     * @param headers\n     * @private\n     */\n\n  }, {\n    key: \"getCanonicalHeaders\",\n    value: function getCanonicalHeaders(headers) {\n      // Sort headers by their lowercased names\n      var sortedHeaders = util_1.objectEntries(headers) // Convert header names to lowercase\n      .map(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            headerName = _ref4[0],\n            value = _ref4[1];\n\n        return [headerName.toLowerCase(), value];\n      }).sort(function (a, b) {\n        return a[0].localeCompare(b[0]);\n      });\n      return sortedHeaders.filter(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            value = _ref6[1];\n\n        return value !== undefined;\n      }).map(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            headerName = _ref8[0],\n            value = _ref8[1];\n\n        // - Convert Array (multi-valued header) into string, delimited by\n        //      ',' (no space).\n        // - Trim leading and trailing spaces.\n        // - Convert sequential (2+) spaces into a single space\n        var canonicalValue = \"\".concat(value).trim().replace(/\\s{2,}/g, ' ');\n        return \"\".concat(headerName, \":\").concat(canonicalValue, \"\\n\");\n      }).join('');\n    }\n  }, {\n    key: \"getCanonicalRequest\",\n    value: function getCanonicalRequest(method, path, query, headers, signedHeaders, contentSha256) {\n      return [method, path, query, headers, signedHeaders, contentSha256 || 'UNSIGNED-PAYLOAD'].join('\\n');\n    }\n  }, {\n    key: \"getCanonicalQueryParams\",\n    value: function getCanonicalQueryParams(query) {\n      return util_1.objectEntries(query).map(function (_ref9) {\n        var _ref10 = _slicedToArray(_ref9, 2),\n            key = _ref10[0],\n            value = _ref10[1];\n\n        return [util_1.encodeURI(key, true), util_1.encodeURI(value, true)];\n      }).sort(function (a, b) {\n        return a[0] < b[0] ? -1 : 1;\n      }).map(function (_ref11) {\n        var _ref12 = _slicedToArray(_ref11, 2),\n            key = _ref12[0],\n            value = _ref12[1];\n\n        return \"\".concat(key, \"=\").concat(value);\n      }).join('&');\n    }\n  }, {\n    key: \"getResourcePath\",\n    value: function getResourcePath(cname, bucket, file) {\n      if (cname) {\n        return '/' + (file || '');\n      } else if (file) {\n        return \"/\".concat(bucket, \"/\").concat(file);\n      } else {\n        return \"/\".concat(bucket);\n      }\n    }\n  }, {\n    key: \"parseExpires\",\n    value: function parseExpires(expires) {\n      var current = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();\n      var expiresInMSeconds = new Date(expires).valueOf();\n\n      if (isNaN(expiresInMSeconds)) {\n        throw new Error('The expiration date provided was invalid.');\n      }\n\n      if (expiresInMSeconds < current.valueOf()) {\n        throw new Error('An expiration date cannot be in the past.');\n      }\n\n      return Math.round(expiresInMSeconds / 1000); // The API expects seconds.\n    }\n  }]);\n\n  return URLSigner;\n}();\n\nexports.URLSigner = URLSigner;\n/**\n * Custom error type for errors related to getting signed errors and policies.\n *\n * @private\n */\n\nvar SigningError = /*#__PURE__*/function (_Error) {\n  _inherits(SigningError, _Error);\n\n  var _super = _createSuper(SigningError);\n\n  function SigningError() {\n    var _this4;\n\n    _classCallCheck(this, SigningError);\n\n    _this4 = _super.apply(this, arguments);\n    _this4.name = 'SigningError';\n    return _this4;\n  }\n\n  return SigningError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.SigningError = SigningError;","map":{"version":3,"sources":["D:/medium clone/node_modules/@google-cloud/storage/build/src/signer.js"],"names":["Object","defineProperty","exports","value","SigningError","URLSigner","PATH_STYLED_HOST","crypto","require","dateFormat","url","util_1","DEFAULT_SIGNING_VERSION","SEVEN_DAYS","authClient","bucket","file","cfg","expiresInSeconds","parseExpires","expires","method","customHost","isVirtualHostedStyle","virtualHostedStyle","cname","name","config","assign","expiration","encodeURI","undefined","version","promise","getSignedUrlV2","getSignedUrlV4","Error","then","query","queryParams","signedUrl","URL","pathname","getResourcePath","search","qsStringify","href","canonicalHeadersString","getCanonicalHeaders","extensionHeaders","resourcePath","blobToSign","contentMd5","contentType","join","sign","signature","getCredentials","credentials","GoogleAccessId","client_email","Expires","Signature","signingErr","message","stack","now","Date","nowInSeconds","Math","floor","valueOf","expiresPeriodInSeconds","fqdn","host","contentSha256","sha256Header","test","signedHeaders","keys","map","header","toLowerCase","sort","extensionHeadersString","datestamp","format","credentialScope","credential","dateISO","toString","canonicalQueryParams","getCanonicalQueryParams","canonicalRequest","getCanonicalRequest","hash","createHash","update","digest","signatureHex","Buffer","from","signedQuery","headers","sortedHeaders","objectEntries","headerName","a","b","localeCompare","filter","canonicalValue","trim","replace","path","key","current","expiresInMSeconds","isNaN","round","arguments"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SigningError = exports.URLSigner = exports.PATH_STYLED_HOST = void 0;\nconst crypto = require(\"crypto\");\nconst dateFormat = require(\"date-and-time\");\nconst url = require(\"url\");\nconst util_1 = require(\"./util\");\n/*\n * Default signing version for getSignedUrl is 'v2'.\n */\nconst DEFAULT_SIGNING_VERSION = 'v2';\nconst SEVEN_DAYS = 604800;\n/**\n * @const {string}\n * @private\n */\nexports.PATH_STYLED_HOST = 'https://storage.googleapis.com';\nclass URLSigner {\n    constructor(authClient, bucket, file) {\n        this.bucket = bucket;\n        this.file = file;\n        this.authClient = authClient;\n    }\n    getSignedUrl(cfg) {\n        const expiresInSeconds = this.parseExpires(cfg.expires);\n        const method = cfg.method;\n        let customHost;\n        // Default style is `path`.\n        const isVirtualHostedStyle = cfg.virtualHostedStyle || false;\n        if (cfg.cname) {\n            customHost = cfg.cname;\n        }\n        else if (isVirtualHostedStyle) {\n            customHost = `https://${this.bucket.name}.storage.googleapis.com`;\n        }\n        const config = Object.assign({}, cfg, {\n            method,\n            expiration: expiresInSeconds,\n            bucket: this.bucket.name,\n            file: this.file ? util_1.encodeURI(this.file.name, false) : undefined,\n        });\n        if (customHost) {\n            config.cname = customHost;\n        }\n        const version = cfg.version || DEFAULT_SIGNING_VERSION;\n        let promise;\n        if (version === 'v2') {\n            promise = this.getSignedUrlV2(config);\n        }\n        else if (version === 'v4') {\n            promise = this.getSignedUrlV4(config);\n        }\n        else {\n            throw new Error(`Invalid signed URL version: ${version}. Supported versions are 'v2' and 'v4'.`);\n        }\n        return promise.then(query => {\n            query = Object.assign(query, cfg.queryParams);\n            const signedUrl = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n            signedUrl.pathname = this.getResourcePath(!!config.cname, this.bucket.name, config.file);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            signedUrl.search = util_1.qsStringify(query);\n            return signedUrl.href;\n        });\n    }\n    getSignedUrlV2(config) {\n        const canonicalHeadersString = this.getCanonicalHeaders(config.extensionHeaders || {});\n        const resourcePath = this.getResourcePath(false, config.bucket, config.file);\n        const blobToSign = [\n            config.method,\n            config.contentMd5 || '',\n            config.contentType || '',\n            config.expiration,\n            canonicalHeadersString + resourcePath,\n        ].join('\\n');\n        const sign = async () => {\n            const authClient = this.authClient;\n            try {\n                const signature = await authClient.sign(blobToSign);\n                const credentials = await authClient.getCredentials();\n                return {\n                    GoogleAccessId: credentials.client_email,\n                    Expires: config.expiration,\n                    Signature: signature,\n                };\n            }\n            catch (err) {\n                const signingErr = new SigningError(err.message);\n                signingErr.stack = err.stack;\n                throw signingErr;\n            }\n        };\n        return sign();\n    }\n    getSignedUrlV4(config) {\n        const now = new Date();\n        const nowInSeconds = Math.floor(now.valueOf() / 1000);\n        const expiresPeriodInSeconds = config.expiration - nowInSeconds;\n        // v4 limit expiration to be 7 days maximum\n        if (expiresPeriodInSeconds > SEVEN_DAYS) {\n            throw new Error(`Max allowed expiration is seven days (${SEVEN_DAYS} seconds).`);\n        }\n        const extensionHeaders = Object.assign({}, config.extensionHeaders);\n        const fqdn = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n        extensionHeaders.host = fqdn.host;\n        if (config.contentMd5) {\n            extensionHeaders['content-md5'] = config.contentMd5;\n        }\n        if (config.contentType) {\n            extensionHeaders['content-type'] = config.contentType;\n        }\n        let contentSha256;\n        const sha256Header = extensionHeaders['x-goog-content-sha256'];\n        if (sha256Header) {\n            if (typeof sha256Header !== 'string' ||\n                !/[A-Fa-f0-9]{40}/.test(sha256Header)) {\n                throw new Error('The header X-Goog-Content-SHA256 must be a hexadecimal string.');\n            }\n            contentSha256 = sha256Header;\n        }\n        const signedHeaders = Object.keys(extensionHeaders)\n            .map(header => header.toLowerCase())\n            .sort()\n            .join(';');\n        const extensionHeadersString = this.getCanonicalHeaders(extensionHeaders);\n        const datestamp = dateFormat.format(now, 'YYYYMMDD', true);\n        const credentialScope = `${datestamp}/auto/storage/goog4_request`;\n        const sign = async () => {\n            const credentials = await this.authClient.getCredentials();\n            const credential = `${credentials.client_email}/${credentialScope}`;\n            const dateISO = dateFormat.format(now, 'YYYYMMDD[T]HHmmss[Z]', true);\n            const queryParams = {\n                'X-Goog-Algorithm': 'GOOG4-RSA-SHA256',\n                'X-Goog-Credential': credential,\n                'X-Goog-Date': dateISO,\n                'X-Goog-Expires': expiresPeriodInSeconds.toString(10),\n                'X-Goog-SignedHeaders': signedHeaders,\n                ...(config.queryParams || {}),\n            };\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const canonicalQueryParams = this.getCanonicalQueryParams(queryParams);\n            const canonicalRequest = this.getCanonicalRequest(config.method, this.getResourcePath(!!config.cname, config.bucket, config.file), canonicalQueryParams, extensionHeadersString, signedHeaders, contentSha256);\n            const hash = crypto\n                .createHash('sha256')\n                .update(canonicalRequest)\n                .digest('hex');\n            const blobToSign = [\n                'GOOG4-RSA-SHA256',\n                dateISO,\n                credentialScope,\n                hash,\n            ].join('\\n');\n            try {\n                const signature = await this.authClient.sign(blobToSign);\n                const signatureHex = Buffer.from(signature, 'base64').toString('hex');\n                const signedQuery = Object.assign({}, queryParams, {\n                    'X-Goog-Signature': signatureHex,\n                });\n                return signedQuery;\n            }\n            catch (err) {\n                const signingErr = new SigningError(err.message);\n                signingErr.stack = err.stack;\n                throw signingErr;\n            }\n        };\n        return sign();\n    }\n    /**\n     * Create canonical headers for signing v4 url.\n     *\n     * The canonical headers for v4-signing a request demands header names are\n     * first lowercased, followed by sorting the header names.\n     * Then, construct the canonical headers part of the request:\n     *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n     *  ..\n     *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n     *\n     * @param headers\n     * @private\n     */\n    getCanonicalHeaders(headers) {\n        // Sort headers by their lowercased names\n        const sortedHeaders = util_1.objectEntries(headers)\n            // Convert header names to lowercase\n            .map(([headerName, value]) => [\n            headerName.toLowerCase(),\n            value,\n        ])\n            .sort((a, b) => a[0].localeCompare(b[0]));\n        return sortedHeaders\n            .filter(([, value]) => value !== undefined)\n            .map(([headerName, value]) => {\n            // - Convert Array (multi-valued header) into string, delimited by\n            //      ',' (no space).\n            // - Trim leading and trailing spaces.\n            // - Convert sequential (2+) spaces into a single space\n            const canonicalValue = `${value}`.trim().replace(/\\s{2,}/g, ' ');\n            return `${headerName}:${canonicalValue}\\n`;\n        })\n            .join('');\n    }\n    getCanonicalRequest(method, path, query, headers, signedHeaders, contentSha256) {\n        return [\n            method,\n            path,\n            query,\n            headers,\n            signedHeaders,\n            contentSha256 || 'UNSIGNED-PAYLOAD',\n        ].join('\\n');\n    }\n    getCanonicalQueryParams(query) {\n        return util_1.objectEntries(query)\n            .map(([key, value]) => [util_1.encodeURI(key, true), util_1.encodeURI(value, true)])\n            .sort((a, b) => (a[0] < b[0] ? -1 : 1))\n            .map(([key, value]) => `${key}=${value}`)\n            .join('&');\n    }\n    getResourcePath(cname, bucket, file) {\n        if (cname) {\n            return '/' + (file || '');\n        }\n        else if (file) {\n            return `/${bucket}/${file}`;\n        }\n        else {\n            return `/${bucket}`;\n        }\n    }\n    parseExpires(expires, current = new Date()) {\n        const expiresInMSeconds = new Date(expires).valueOf();\n        if (isNaN(expiresInMSeconds)) {\n            throw new Error('The expiration date provided was invalid.');\n        }\n        if (expiresInMSeconds < current.valueOf()) {\n            throw new Error('An expiration date cannot be in the past.');\n        }\n        return Math.round(expiresInMSeconds / 1000); // The API expects seconds.\n    }\n}\nexports.URLSigner = URLSigner;\n/**\n * Custom error type for errors related to getting signed errors and policies.\n *\n * @private\n */\nclass SigningError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'SigningError';\n    }\n}\nexports.SigningError = SigningError;\n//# sourceMappingURL=signer.js.map"]},"metadata":{},"sourceType":"script"}