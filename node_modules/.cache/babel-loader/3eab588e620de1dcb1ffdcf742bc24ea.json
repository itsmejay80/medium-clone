{"ast":null,"code":"\"use strict\"; // Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _createForOfIteratorHelper = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar document_1 = require(\"./document\");\n\nvar reference_1 = require(\"./reference\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar validate_1 = require(\"./validate\");\n\nvar BUNDLE_VERSION = 1;\n/**\n * Builds a Firestore data bundle with results from the given document and query snapshots.\n *\n * @private\n */\n\nvar BundleBuilder = /*#__PURE__*/function () {\n  function BundleBuilder(bundleId) {\n    _classCallCheck(this, BundleBuilder);\n\n    this.bundleId = bundleId; // Resulting documents for the bundle, keyed by full document path.\n\n    this.documents = new Map(); // Named queries saved in the bundle, keyed by query name.\n\n    this.namedQueries = new Map(); // The latest read time among all bundled documents and queries.\n\n    this.latestReadTime = new timestamp_1.Timestamp(0, 0);\n  }\n  /**\n   * Adds a Firestore document snapshot or query snapshot to the bundle.\n   * Both the documents data and the query read time will be included in the bundle.\n   *\n   * @param {DocumentSnapshot | string} documentOrName A document snapshot to add or a name of a query.\n   * @param {Query=} querySnapshot A query snapshot to add to the bundle, if provided.\n   * @returns {BundleBuilder} This instance.\n   *\n   * @example\n   * const bundle = firestore.bundle('data-bundle');\n   * const docSnapshot = await firestore.doc('abc/123').get();\n   * const querySnapshot = await firestore.collection('coll').get();\n   *\n   * const bundleBuffer = bundle.add(docSnapshot); // Add a document\n   *                            .add('coll-query', querySnapshot) // Add a named query.\n   *                            .build()\n   * // Save `bundleBuffer` to CDN or stream it to clients.\n   */\n\n\n  _createClass(BundleBuilder, [{\n    key: \"add\",\n    value: function add(documentOrName, querySnapshot) {\n      // eslint-disable-next-line prefer-rest-params\n      validate_1.validateMinNumberOfArguments('BundleBuilder.add', arguments, 1); // eslint-disable-next-line prefer-rest-params\n\n      validate_1.validateMaxNumberOfArguments('BundleBuilder.add', arguments, 2);\n\n      if (arguments.length === 1) {\n        validateDocumentSnapshot('documentOrName', documentOrName);\n        this.addBundledDocument(documentOrName);\n      } else {\n        validate_1.validateString('documentOrName', documentOrName);\n        validateQuerySnapshot('querySnapshot', querySnapshot);\n        this.addNamedQuery(documentOrName, querySnapshot);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"addBundledDocument\",\n    value: function addBundledDocument(snap) {\n      var docProto = snap.toDocumentProto();\n      this.documents.set(snap.id, {\n        document: snap.exists ? docProto : undefined,\n        metadata: {\n          name: docProto.name,\n          readTime: snap.readTime.toProto().timestampValue,\n          exists: snap.exists\n        }\n      });\n\n      if (snap.readTime > this.latestReadTime) {\n        this.latestReadTime = snap.readTime;\n      }\n    }\n  }, {\n    key: \"addNamedQuery\",\n    value: function addNamedQuery(name, querySnap) {\n      if (this.namedQueries.has(name)) {\n        throw new Error(\"Query name conflict: \".concat(name, \" is already added.\"));\n      }\n\n      this.namedQueries.set(name, {\n        name: name,\n        bundledQuery: querySnap.query._toBundledQuery(),\n        readTime: querySnap.readTime.toProto().timestampValue\n      });\n\n      var _iterator = _createForOfIteratorHelper(querySnap.docs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var snap = _step.value;\n          this.addBundledDocument(snap);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (querySnap.readTime > this.latestReadTime) {\n        this.latestReadTime = querySnap.readTime;\n      }\n    }\n    /**\n     * Converts a IBundleElement to a Buffer whose content is the length prefixed JSON representation\n     * of the element.\n     * @private\n     */\n\n  }, {\n    key: \"elementToLengthPrefixedBuffer\",\n    value: function elementToLengthPrefixedBuffer(bundleElement) {\n      var buffer = Buffer.from(JSON.stringify(bundleElement), 'utf-8');\n      var lengthBuffer = Buffer.from(buffer.length.toString());\n      return Buffer.concat([lengthBuffer, buffer]);\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      var bundleBuffer = Buffer.alloc(0);\n\n      var _iterator2 = _createForOfIteratorHelper(this.namedQueries.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var namedQuery = _step2.value;\n          bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n            namedQuery: namedQuery\n          })]);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(this.documents.values()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var bundledDocument = _step3.value;\n          var documentMetadata = bundledDocument.metadata;\n          bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n            documentMetadata: documentMetadata\n          })]); // Write to the bundle if document exists.\n\n          var document = bundledDocument.document;\n\n          if (document) {\n            bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n              document: document\n            })]);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var metadata = {\n        id: this.bundleId,\n        createTime: this.latestReadTime.toProto().timestampValue,\n        version: BUNDLE_VERSION,\n        totalDocuments: this.documents.size,\n        totalBytes: bundleBuffer.length\n      }; // Prepends the metadata element to the bundleBuffer: `bundleBuffer` is the second argument to `Buffer.concat`.\n\n      bundleBuffer = Buffer.concat([this.elementToLengthPrefixedBuffer({\n        metadata: metadata\n      }), bundleBuffer]);\n      return bundleBuffer;\n    }\n  }]);\n\n  return BundleBuilder;\n}();\n\nexports.BundleBuilder = BundleBuilder;\n/**\n * Convenient class to hold both the metadata and the actual content of a document to be bundled.\n * @private\n */\n\nvar BundledDocument = function BundledDocument(metadata, document) {\n  _classCallCheck(this, BundledDocument);\n\n  this.metadata = metadata;\n  this.document = document;\n};\n/**\n * Validates that 'value' is DocumentSnapshot.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\n\n\nfunction validateDocumentSnapshot(arg, value) {\n  if (!(value instanceof document_1.DocumentSnapshot)) {\n    throw new Error(validate_1.invalidArgumentMessage(arg, 'DocumentSnapshot'));\n  }\n}\n/**\n * Validates that 'value' is QuerySnapshot.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\n\n\nfunction validateQuerySnapshot(arg, value) {\n  if (!(value instanceof reference_1.QuerySnapshot)) {\n    throw new Error(validate_1.invalidArgumentMessage(arg, 'QuerySnapshot'));\n  }\n}","map":{"version":3,"sources":["D:/medium clone/node_modules/@google-cloud/firestore/build/src/bundle.js"],"names":["Object","defineProperty","exports","value","document_1","require","reference_1","timestamp_1","validate_1","BUNDLE_VERSION","BundleBuilder","bundleId","documents","Map","namedQueries","latestReadTime","Timestamp","documentOrName","querySnapshot","validateMinNumberOfArguments","arguments","validateMaxNumberOfArguments","length","validateDocumentSnapshot","addBundledDocument","validateString","validateQuerySnapshot","addNamedQuery","snap","docProto","toDocumentProto","set","id","document","exists","undefined","metadata","name","readTime","toProto","timestampValue","querySnap","has","Error","bundledQuery","query","_toBundledQuery","docs","bundleElement","buffer","Buffer","from","JSON","stringify","lengthBuffer","toString","concat","bundleBuffer","alloc","values","namedQuery","elementToLengthPrefixedBuffer","bundledDocument","documentMetadata","createTime","version","totalDocuments","size","totalBytes","BundledDocument","arg","DocumentSnapshot","invalidArgumentMessage","QuerySnapshot"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst document_1 = require(\"./document\");\nconst reference_1 = require(\"./reference\");\nconst timestamp_1 = require(\"./timestamp\");\nconst validate_1 = require(\"./validate\");\nconst BUNDLE_VERSION = 1;\n/**\n * Builds a Firestore data bundle with results from the given document and query snapshots.\n *\n * @private\n */\nclass BundleBuilder {\n    constructor(bundleId) {\n        this.bundleId = bundleId;\n        // Resulting documents for the bundle, keyed by full document path.\n        this.documents = new Map();\n        // Named queries saved in the bundle, keyed by query name.\n        this.namedQueries = new Map();\n        // The latest read time among all bundled documents and queries.\n        this.latestReadTime = new timestamp_1.Timestamp(0, 0);\n    }\n    /**\n     * Adds a Firestore document snapshot or query snapshot to the bundle.\n     * Both the documents data and the query read time will be included in the bundle.\n     *\n     * @param {DocumentSnapshot | string} documentOrName A document snapshot to add or a name of a query.\n     * @param {Query=} querySnapshot A query snapshot to add to the bundle, if provided.\n     * @returns {BundleBuilder} This instance.\n     *\n     * @example\n     * const bundle = firestore.bundle('data-bundle');\n     * const docSnapshot = await firestore.doc('abc/123').get();\n     * const querySnapshot = await firestore.collection('coll').get();\n     *\n     * const bundleBuffer = bundle.add(docSnapshot); // Add a document\n     *                            .add('coll-query', querySnapshot) // Add a named query.\n     *                            .build()\n     * // Save `bundleBuffer` to CDN or stream it to clients.\n     */\n    add(documentOrName, querySnapshot) {\n        // eslint-disable-next-line prefer-rest-params\n        validate_1.validateMinNumberOfArguments('BundleBuilder.add', arguments, 1);\n        // eslint-disable-next-line prefer-rest-params\n        validate_1.validateMaxNumberOfArguments('BundleBuilder.add', arguments, 2);\n        if (arguments.length === 1) {\n            validateDocumentSnapshot('documentOrName', documentOrName);\n            this.addBundledDocument(documentOrName);\n        }\n        else {\n            validate_1.validateString('documentOrName', documentOrName);\n            validateQuerySnapshot('querySnapshot', querySnapshot);\n            this.addNamedQuery(documentOrName, querySnapshot);\n        }\n        return this;\n    }\n    addBundledDocument(snap) {\n        const docProto = snap.toDocumentProto();\n        this.documents.set(snap.id, {\n            document: snap.exists ? docProto : undefined,\n            metadata: {\n                name: docProto.name,\n                readTime: snap.readTime.toProto().timestampValue,\n                exists: snap.exists,\n            },\n        });\n        if (snap.readTime > this.latestReadTime) {\n            this.latestReadTime = snap.readTime;\n        }\n    }\n    addNamedQuery(name, querySnap) {\n        if (this.namedQueries.has(name)) {\n            throw new Error(`Query name conflict: ${name} is already added.`);\n        }\n        this.namedQueries.set(name, {\n            name,\n            bundledQuery: querySnap.query._toBundledQuery(),\n            readTime: querySnap.readTime.toProto().timestampValue,\n        });\n        for (const snap of querySnap.docs) {\n            this.addBundledDocument(snap);\n        }\n        if (querySnap.readTime > this.latestReadTime) {\n            this.latestReadTime = querySnap.readTime;\n        }\n    }\n    /**\n     * Converts a IBundleElement to a Buffer whose content is the length prefixed JSON representation\n     * of the element.\n     * @private\n     */\n    elementToLengthPrefixedBuffer(bundleElement) {\n        const buffer = Buffer.from(JSON.stringify(bundleElement), 'utf-8');\n        const lengthBuffer = Buffer.from(buffer.length.toString());\n        return Buffer.concat([lengthBuffer, buffer]);\n    }\n    build() {\n        let bundleBuffer = Buffer.alloc(0);\n        for (const namedQuery of this.namedQueries.values()) {\n            bundleBuffer = Buffer.concat([\n                bundleBuffer,\n                this.elementToLengthPrefixedBuffer({ namedQuery }),\n            ]);\n        }\n        for (const bundledDocument of this.documents.values()) {\n            const documentMetadata = bundledDocument.metadata;\n            bundleBuffer = Buffer.concat([\n                bundleBuffer,\n                this.elementToLengthPrefixedBuffer({ documentMetadata }),\n            ]);\n            // Write to the bundle if document exists.\n            const document = bundledDocument.document;\n            if (document) {\n                bundleBuffer = Buffer.concat([\n                    bundleBuffer,\n                    this.elementToLengthPrefixedBuffer({ document }),\n                ]);\n            }\n        }\n        const metadata = {\n            id: this.bundleId,\n            createTime: this.latestReadTime.toProto().timestampValue,\n            version: BUNDLE_VERSION,\n            totalDocuments: this.documents.size,\n            totalBytes: bundleBuffer.length,\n        };\n        // Prepends the metadata element to the bundleBuffer: `bundleBuffer` is the second argument to `Buffer.concat`.\n        bundleBuffer = Buffer.concat([\n            this.elementToLengthPrefixedBuffer({ metadata }),\n            bundleBuffer,\n        ]);\n        return bundleBuffer;\n    }\n}\nexports.BundleBuilder = BundleBuilder;\n/**\n * Convenient class to hold both the metadata and the actual content of a document to be bundled.\n * @private\n */\nclass BundledDocument {\n    constructor(metadata, document) {\n        this.metadata = metadata;\n        this.document = document;\n    }\n}\n/**\n * Validates that 'value' is DocumentSnapshot.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\nfunction validateDocumentSnapshot(arg, value) {\n    if (!(value instanceof document_1.DocumentSnapshot)) {\n        throw new Error(validate_1.invalidArgumentMessage(arg, 'DocumentSnapshot'));\n    }\n}\n/**\n * Validates that 'value' is QuerySnapshot.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\nfunction validateQuerySnapshot(arg, value) {\n    if (!(value instanceof reference_1.QuerySnapshot)) {\n        throw new Error(validate_1.invalidArgumentMessage(arg, 'QuerySnapshot'));\n    }\n}\n//# sourceMappingURL=bundle.js.map"]},"metadata":{},"sourceType":"script"}