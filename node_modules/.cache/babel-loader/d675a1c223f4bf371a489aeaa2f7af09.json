{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _toConsumableArray = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _asyncToGenerator = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar google_gax_1 = require(\"google-gax\");\n\nvar assert = require(\"assert\");\n\nvar backoff_1 = require(\"./backoff\");\n\nvar rate_limiter_1 = require(\"./rate-limiter\");\n\nvar util_1 = require(\"./util\");\n\nvar write_batch_1 = require(\"./write-batch\");\n\nvar logger_1 = require(\"./logger\");\n/*!\n * The maximum number of writes that can be in a single batch.\n */\n\n\nvar MAX_BATCH_SIZE = 20;\n/*!\n * The starting maximum number of operations per second as allowed by the\n * 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\n\nvar STARTING_MAXIMUM_OPS_PER_SECOND = 500;\n/*!\n * The rate by which to increase the capacity as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\n\nvar RATE_LIMITER_MULTIPLIER = 1.5;\n/*!\n * How often the operations per second capacity should increase in milliseconds\n * as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\n\nvar RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;\n/*!\n * Used to represent the state of batch.\n *\n * Writes can only be added while the batch is OPEN. For a batch to be sent,\n * the batch must be READY_TO_SEND. After a batch is sent, it is marked as SENT.\n */\n\nvar BatchState;\n\n(function (BatchState) {\n  BatchState[BatchState[\"OPEN\"] = 0] = \"OPEN\";\n  BatchState[BatchState[\"READY_TO_SEND\"] = 1] = \"READY_TO_SEND\";\n  BatchState[BatchState[\"SENT\"] = 2] = \"SENT\";\n})(BatchState || (BatchState = {}));\n/**\n * Used to represent a batch on the BatchQueue.\n *\n * @private\n */\n\n\nvar BulkCommitBatch = /*#__PURE__*/function () {\n  function BulkCommitBatch(firestore, writeBatch, maxBatchSize) {\n    _classCallCheck(this, BulkCommitBatch);\n\n    this.firestore = firestore;\n    this.writeBatch = writeBatch;\n    this.maxBatchSize = maxBatchSize;\n    /**\n     * The state of the batch.\n     */\n\n    this.state = BatchState.OPEN; // A deferred promise that is resolved after the batch has been sent, and a\n    // response is received.\n\n    this.completedDeferred = new util_1.Deferred(); // A map from each write's document path to its corresponding result.\n    // Only contains writes that have not been resolved.\n\n    this.pendingOps = new Map();\n    this.backoff = new backoff_1.ExponentialBackoff();\n  }\n  /**\n   * The number of writes in this batch.\n   */\n\n\n  _createClass(BulkCommitBatch, [{\n    key: \"create\",\n\n    /**\n     * Adds a `create` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n    value: function create(documentRef, data) {\n      this.writeBatch.create(documentRef, data);\n      return this.processOperation(documentRef);\n    }\n    /**\n     * Adds a `delete` operation to the WriteBatch. Returns a promise that\n     * resolves with the sentinel value (Timestamp(0)) for the delete operation.\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(documentRef, precondition) {\n      this.writeBatch.delete(documentRef, precondition);\n      return this.processOperation(documentRef);\n    }\n    /**\n     * Adds a `set` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(documentRef, data, options) {\n      this.writeBatch.set(documentRef, data, options);\n      return this.processOperation(documentRef);\n    }\n    /**\n     * Adds an `update` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(documentRef, dataOrField) {\n      var _this$writeBatch;\n\n      for (var _len = arguments.length, preconditionOrValues = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        preconditionOrValues[_key - 2] = arguments[_key];\n      }\n\n      (_this$writeBatch = this.writeBatch).update.apply(_this$writeBatch, [documentRef, dataOrField].concat(preconditionOrValues));\n\n      return this.processOperation(documentRef);\n    }\n    /**\n     * Helper to update data structures associated with the operation and\n     * return the result.\n     */\n\n  }, {\n    key: \"processOperation\",\n    value: function processOperation(documentRef) {\n      assert(!this.pendingOps.has(documentRef.path), 'Batch should not contain writes to the same document');\n      assert(this.state === BatchState.OPEN, 'Batch should be OPEN when adding writes');\n      var deferred = new util_1.Deferred();\n      this.pendingOps.set(documentRef.path, deferred);\n\n      if (this.opCount === this.maxBatchSize) {\n        this.state = BatchState.READY_TO_SEND;\n      }\n\n      return deferred.promise.then(function (result) {\n        if (result.writeTime) {\n          return new write_batch_1.WriteResult(result.writeTime);\n        } else {\n          throw result.status;\n        }\n      });\n    }\n    /**\n     * Commits the batch and returns a promise that resolves when all the writes\n     * in the batch have finished.\n     *\n     * If any writes in the batch fail with a retryable error, this method will\n     * retry the failed writes.\n     */\n\n  }, {\n    key: \"bulkCommit\",\n    value: function () {\n      var _bulkCommit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var stack, results, attempt;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                assert(this.state === BatchState.READY_TO_SEND, 'The batch should be marked as READY_TO_SEND before committing');\n                this.state = BatchState.SENT; // Capture the error stack to preserve stack tracing across async calls.\n\n                stack = Error().stack;\n                results = [];\n                attempt = 0;\n\n              case 5:\n                if (!(attempt < backoff_1.MAX_RETRY_ATTEMPTS)) {\n                  _context.next = 28;\n                  break;\n                }\n\n                _context.next = 8;\n                return this.backoff.backoffAndWait();\n\n              case 8:\n                _context.prev = 8;\n                _context.next = 11;\n                return this.writeBatch.bulkCommit();\n\n              case 11:\n                results = _context.sent;\n                _context.next = 17;\n                break;\n\n              case 14:\n                _context.prev = 14;\n                _context.t0 = _context[\"catch\"](8);\n                // Map the failure to each individual write's result.\n                results = _toConsumableArray(this.pendingOps.keys()).map(function (path) {\n                  return {\n                    key: path,\n                    writeTime: null,\n                    status: util_1.wrapError(_context.t0, stack)\n                  };\n                });\n\n              case 17:\n                this.processResults(results);\n\n                if (!(this.pendingOps.size > 0)) {\n                  _context.next = 23;\n                  break;\n                }\n\n                logger_1.logger('BulkWriter.bulkCommit', null, \"Current batch failed at retry #\".concat(attempt, \". Num failures: \") + \"\".concat(this.pendingOps.size, \".\"));\n                this.writeBatch = new write_batch_1.WriteBatch(this.firestore, this.writeBatch, _toConsumableArray(this.pendingOps.keys()));\n                _context.next = 25;\n                break;\n\n              case 23:\n                this.completedDeferred.resolve();\n                return _context.abrupt(\"return\");\n\n              case 25:\n                attempt++;\n                _context.next = 5;\n                break;\n\n              case 28:\n                this.failRemainingOperations(results);\n                this.completedDeferred.resolve();\n\n              case 30:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[8, 14]]);\n      }));\n\n      function bulkCommit() {\n        return _bulkCommit.apply(this, arguments);\n      }\n\n      return bulkCommit;\n    }()\n    /**\n     * Resolves the individual operations in the batch with the results.\n     */\n\n  }, {\n    key: \"processResults\",\n    value: function processResults(results) {\n      var _iterator = _createForOfIteratorHelper(results),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var result = _step.value;\n\n          if (result.status.code === google_gax_1.Status.OK) {\n            this.pendingOps.get(result.key).resolve(result);\n            this.pendingOps.delete(result.key);\n          } else if (!this.shouldRetry(result.status.code)) {\n            this.pendingOps.get(result.key).reject(result.status);\n            this.pendingOps.delete(result.key);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"failRemainingOperations\",\n    value: function failRemainingOperations(results) {\n      var _iterator2 = _createForOfIteratorHelper(results),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var result = _step2.value;\n          assert(result.status.code !== google_gax_1.Status.OK, 'Should not fail successful operation');\n          this.pendingOps.get(result.key).reject(result.status);\n          this.pendingOps.delete(result.key);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"shouldRetry\",\n    value: function shouldRetry(code) {\n      var retryCodes = util_1.getRetryCodes('batchWrite');\n      return code !== undefined && retryCodes.includes(code);\n    }\n  }, {\n    key: \"hasPath\",\n    value: function hasPath(path) {\n      var _iterator3 = _createForOfIteratorHelper(this.pendingOps),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 1),\n              docPath = _step3$value[0];\n\n          if (docPath === path) return true;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"docPaths\",\n    value: function docPaths() {\n      return this.pendingOps.keys();\n    }\n    /**\n     * Returns a promise that resolves when the batch has been sent, and a\n     * response is received.\n     */\n\n  }, {\n    key: \"awaitBulkCommit\",\n    value: function awaitBulkCommit() {\n      this.markReadyToSend();\n      return this.completedDeferred.promise;\n    }\n  }, {\n    key: \"markReadyToSend\",\n    value: function markReadyToSend() {\n      if (this.state === BatchState.OPEN) {\n        this.state = BatchState.READY_TO_SEND;\n      }\n    }\n  }, {\n    key: \"opCount\",\n    get: function get() {\n      return this.pendingOps.size;\n    }\n  }]);\n\n  return BulkCommitBatch;\n}();\n/**\n * A Firestore BulkWriter than can be used to perform a large number of writes\n * in parallel. Writes to the same document will be executed sequentially.\n *\n * @class\n */\n\n\nvar BulkWriter = /*#__PURE__*/function () {\n  function BulkWriter(firestore, enableThrottling) {\n    _classCallCheck(this, BulkWriter);\n\n    this.firestore = firestore;\n    /**\n     * The maximum number of writes that can be in a single batch.\n     */\n\n    this.maxBatchSize = MAX_BATCH_SIZE;\n    /**\n     * A queue of batches to be written.\n     */\n\n    this.batchQueue = [];\n    /**\n     * Whether this BulkWriter instance is closed. Once closed, it cannot be\n     * opened again.\n     */\n\n    this.closed = false;\n\n    this.firestore._incrementBulkWritersCount();\n\n    if (enableThrottling) {\n      this.rateLimiter = new rate_limiter_1.RateLimiter(STARTING_MAXIMUM_OPS_PER_SECOND, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS);\n    } else {\n      this.rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n    }\n  }\n  /**\n   * Create a document with the provided data. This single operation will fail\n   * if a document exists at its location.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * created.\n   * @param {T} data The object to serialize as the document.\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\n   * the write. Throws an error if the write fails.\n   *\n   * @example\n   * let bulkWriter = firestore.bulkWriter();\n   * let documentRef = firestore.collection('col').doc();\n   *\n   * bulkWriter\n   *  .create(documentRef, {foo: 'bar'})\n   *  .then(result => {\n   *    console.log('Successfully executed write at: ', result);\n   *  })\n   *  .catch(err => {\n   *    console.log('Write failed with: ', err);\n   *  });\n   * });\n   */\n\n\n  _createClass(BulkWriter, [{\n    key: \"create\",\n    value: function create(documentRef, data) {\n      this.verifyNotClosed();\n      var bulkCommitBatch = this.getEligibleBatch(documentRef);\n      var resultPromise = bulkCommitBatch.create(documentRef, data);\n      this.sendReadyBatches();\n      return resultPromise;\n    }\n    /**\n     * Delete a document from the database.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the batch if the\n     * document doesn't exist or was last updated at a different time.\n     * @returns {Promise<WriteResult>} A promise that resolves with a sentinel\n     * Timestamp indicating that the delete was successful. Throws an error if\n     * the write fails.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .delete(documentRef)\n     *  .then(result => {\n     *    console.log('Successfully deleted document');\n     *  })\n     *  .catch(err => {\n     *    console.log('Delete failed with: ', err);\n     *  });\n     * });\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(documentRef, precondition) {\n      this.verifyNotClosed();\n      var bulkCommitBatch = this.getEligibleBatch(documentRef);\n      var resultPromise = bulkCommitBatch.delete(documentRef, precondition);\n      this.sendReadyBatches();\n      return resultPromise;\n    }\n    /**\n     * Write to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document does not\n     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,\n     * the provided data can be merged into the existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call remain\n     * untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()\n     * only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * bulkWriter\n     *  .set(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(documentRef, data, options) {\n      this.verifyNotClosed();\n      var bulkCommitBatch = this.getEligibleBatch(documentRef);\n      var resultPromise = bulkCommitBatch.set(documentRef, data, options);\n      this.sendReadyBatches();\n      return resultPromise;\n    }\n    /**\n     * Update fields of the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document doesn't yet\n     * exist, the update fails and the entire batch will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n     * fields and values with which to update the document or the path of the\n     * first field to update.\n     * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An\n     * alternating list of field paths and values to update or a Precondition to\n     * restrict this update\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .update(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(documentRef, dataOrField) {\n      this.verifyNotClosed();\n      var bulkCommitBatch = this.getEligibleBatch(documentRef);\n\n      for (var _len2 = arguments.length, preconditionOrValues = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        preconditionOrValues[_key2 - 2] = arguments[_key2];\n      }\n\n      var resultPromise = bulkCommitBatch.update.apply(bulkCommitBatch, [documentRef, dataOrField].concat(preconditionOrValues));\n      this.sendReadyBatches();\n      return resultPromise;\n    }\n    /**\n     * Commits all writes that have been enqueued up to this point in parallel.\n     *\n     * Returns a Promise that resolves when all currently queued operations have\n     * been committed. The Promise will never be rejected since the results for\n     * each individual operation are conveyed via their individual Promises.\n     *\n     * The Promise resolves immediately if there are no pending writes. Otherwise,\n     * the Promise waits for all previously issued writes, but it does not wait\n     * for writes that were added after the method is called. If you want to wait\n     * for additional writes, call `flush()` again.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await flush().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n\n  }, {\n    key: \"flush\",\n    value: function () {\n      var _flush = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var trackedBatches, writePromises;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.verifyNotClosed();\n                trackedBatches = this.batchQueue;\n                writePromises = trackedBatches.map(function (batch) {\n                  return batch.awaitBulkCommit();\n                });\n                this.sendReadyBatches();\n                _context2.next = 6;\n                return Promise.all(writePromises);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function flush() {\n        return _flush.apply(this, arguments);\n      }\n\n      return flush;\n    }()\n    /**\n     * Commits all enqueued writes and marks the BulkWriter instance as closed.\n     *\n     * After calling `close()`, calling any method wil throw an error.\n     *\n     * Returns a Promise that resolves when there are no more pending writes. The\n     * Promise will never be rejected. Calling this method will send all requests.\n     * The promise resolves immediately if there are no pending writes.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await close().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.verifyNotClosed();\n\n      this.firestore._decrementBulkWritersCount();\n\n      var flushPromise = this.flush();\n      this.closed = true;\n      return flushPromise;\n    }\n  }, {\n    key: \"verifyNotClosed\",\n    value: function verifyNotClosed() {\n      if (this.closed) {\n        throw new Error('BulkWriter has already been closed.');\n      }\n    }\n    /**\n     * Return the first eligible batch that can hold a write to the provided\n     * reference, or creates one if no eligible batches are found.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"getEligibleBatch\",\n    value: function getEligibleBatch(ref) {\n      if (this.batchQueue.length > 0) {\n        var lastBatch = this.batchQueue[this.batchQueue.length - 1];\n\n        if (lastBatch.state === BatchState.OPEN && !lastBatch.hasPath(ref.path)) {\n          return lastBatch;\n        }\n      }\n\n      return this.createNewBatch();\n    }\n    /**\n     * Creates a new batch and adds it to the BatchQueue. If there is already a\n     * batch enqueued, sends the batch after a new one is created.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"createNewBatch\",\n    value: function createNewBatch() {\n      var newBatch = new BulkCommitBatch(this.firestore, this.firestore.batch(), this.maxBatchSize);\n\n      if (this.batchQueue.length > 0) {\n        this.batchQueue[this.batchQueue.length - 1].markReadyToSend();\n        this.sendReadyBatches();\n      }\n\n      this.batchQueue.push(newBatch);\n      return newBatch;\n    }\n    /**\n     * Attempts to send batches starting from the front of the BatchQueue until a\n     * batch cannot be sent.\n     *\n     * After a batch is complete, try sending batches again.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"sendReadyBatches\",\n    value: function sendReadyBatches() {\n      var _this = this;\n\n      var unsentBatches = this.batchQueue.filter(function (batch) {\n        return batch.state === BatchState.READY_TO_SEND;\n      });\n      var index = 0;\n\n      while (index < unsentBatches.length && this.isBatchSendable(unsentBatches[index])) {\n        var batch = unsentBatches[index]; // Send the batch if it is under the rate limit, or schedule another\n        // attempt after the appropriate timeout.\n\n        var delayMs = this.rateLimiter.getNextRequestDelayMs(batch.opCount);\n        assert(delayMs !== -1, 'Batch size should be under capacity');\n\n        if (delayMs === 0) {\n          this.sendBatch(batch);\n        } else {\n          backoff_1.delayExecution(function () {\n            return _this.sendReadyBatches();\n          }, delayMs);\n          break;\n        }\n\n        index++;\n      }\n    }\n    /**\n     * Sends the provided batch and processes the results. After the batch is\n     * committed, sends the next group of ready batches.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"sendBatch\",\n    value: function sendBatch(batch) {\n      var _this2 = this;\n\n      var success = this.rateLimiter.tryMakeRequest(batch.opCount);\n      assert(success, 'Batch should be under rate limit to be sent.');\n      batch.bulkCommit().then(function () {\n        // Remove the batch from the BatchQueue after it has been processed.\n        var batchIndex = _this2.batchQueue.indexOf(batch);\n\n        assert(batchIndex !== -1, 'The batch should be in the BatchQueue');\n\n        _this2.batchQueue.splice(batchIndex, 1);\n\n        _this2.sendReadyBatches();\n      });\n    }\n    /**\n     * Checks that the provided batch is sendable. To be sendable, a batch must:\n     * (1) be marked as READY_TO_SEND\n     * (2) not write to references that are currently in flight\n     *\n     * @private\n     */\n\n  }, {\n    key: \"isBatchSendable\",\n    value: function isBatchSendable(batch) {\n      var _this3 = this;\n\n      if (batch.state !== BatchState.READY_TO_SEND) {\n        return false;\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(batch.docPaths()),\n          _step4;\n\n      try {\n        var _loop = function _loop() {\n          var path = _step4.value;\n          var isRefInFlight = _this3.batchQueue.filter(function (batch) {\n            return batch.state === BatchState.SENT;\n          }).find(function (batch) {\n            return batch.hasPath(path);\n          }) !== undefined;\n\n          if (isRefInFlight) {\n            // eslint-disable-next-line no-console\n            console.warn('[BulkWriter]', \"Duplicate write to document \\\"\".concat(path, \"\\\" detected.\"), 'Writing to the same document multiple times will slow down BulkWriter. ' + 'Write to unique documents in order to maximize throughput.');\n            return {\n              v: false\n            };\n          }\n        };\n\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _ret = _loop();\n\n          if (typeof _ret === \"object\") return _ret.v;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return true;\n    }\n    /**\n     * Sets the maximum number of allowed operations in a batch.\n     *\n     * @private\n     */\n    // Visible for testing.\n\n  }, {\n    key: \"_setMaxBatchSize\",\n    value: function _setMaxBatchSize(size) {\n      this.maxBatchSize = size;\n    }\n  }]);\n\n  return BulkWriter;\n}();\n\nexports.BulkWriter = BulkWriter;","map":{"version":3,"sources":["D:/medium clone/node_modules/@google-cloud/firestore/build/src/bulk-writer.js"],"names":["Object","defineProperty","exports","value","google_gax_1","require","assert","backoff_1","rate_limiter_1","util_1","write_batch_1","logger_1","MAX_BATCH_SIZE","STARTING_MAXIMUM_OPS_PER_SECOND","RATE_LIMITER_MULTIPLIER","RATE_LIMITER_MULTIPLIER_MILLIS","BatchState","BulkCommitBatch","firestore","writeBatch","maxBatchSize","state","OPEN","completedDeferred","Deferred","pendingOps","Map","backoff","ExponentialBackoff","documentRef","data","create","processOperation","precondition","delete","options","set","dataOrField","preconditionOrValues","update","has","path","deferred","opCount","READY_TO_SEND","promise","then","result","writeTime","WriteResult","status","SENT","stack","Error","results","attempt","MAX_RETRY_ATTEMPTS","backoffAndWait","bulkCommit","keys","map","key","wrapError","processResults","size","logger","WriteBatch","resolve","failRemainingOperations","code","Status","OK","get","shouldRetry","reject","retryCodes","getRetryCodes","undefined","includes","docPath","markReadyToSend","BulkWriter","enableThrottling","batchQueue","closed","_incrementBulkWritersCount","rateLimiter","RateLimiter","Number","POSITIVE_INFINITY","verifyNotClosed","bulkCommitBatch","getEligibleBatch","resultPromise","sendReadyBatches","trackedBatches","writePromises","batch","awaitBulkCommit","Promise","all","_decrementBulkWritersCount","flushPromise","flush","ref","length","lastBatch","hasPath","createNewBatch","newBatch","push","unsentBatches","filter","index","isBatchSendable","delayMs","getNextRequestDelayMs","sendBatch","delayExecution","success","tryMakeRequest","batchIndex","indexOf","splice","docPaths","isRefInFlight","find","console","warn"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst google_gax_1 = require(\"google-gax\");\nconst assert = require(\"assert\");\nconst backoff_1 = require(\"./backoff\");\nconst rate_limiter_1 = require(\"./rate-limiter\");\nconst util_1 = require(\"./util\");\nconst write_batch_1 = require(\"./write-batch\");\nconst logger_1 = require(\"./logger\");\n/*!\n * The maximum number of writes that can be in a single batch.\n */\nconst MAX_BATCH_SIZE = 20;\n/*!\n * The starting maximum number of operations per second as allowed by the\n * 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\nconst STARTING_MAXIMUM_OPS_PER_SECOND = 500;\n/*!\n * The rate by which to increase the capacity as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\nconst RATE_LIMITER_MULTIPLIER = 1.5;\n/*!\n * How often the operations per second capacity should increase in milliseconds\n * as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\nconst RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;\n/*!\n * Used to represent the state of batch.\n *\n * Writes can only be added while the batch is OPEN. For a batch to be sent,\n * the batch must be READY_TO_SEND. After a batch is sent, it is marked as SENT.\n */\nvar BatchState;\n(function (BatchState) {\n    BatchState[BatchState[\"OPEN\"] = 0] = \"OPEN\";\n    BatchState[BatchState[\"READY_TO_SEND\"] = 1] = \"READY_TO_SEND\";\n    BatchState[BatchState[\"SENT\"] = 2] = \"SENT\";\n})(BatchState || (BatchState = {}));\n/**\n * Used to represent a batch on the BatchQueue.\n *\n * @private\n */\nclass BulkCommitBatch {\n    constructor(firestore, writeBatch, maxBatchSize) {\n        this.firestore = firestore;\n        this.writeBatch = writeBatch;\n        this.maxBatchSize = maxBatchSize;\n        /**\n         * The state of the batch.\n         */\n        this.state = BatchState.OPEN;\n        // A deferred promise that is resolved after the batch has been sent, and a\n        // response is received.\n        this.completedDeferred = new util_1.Deferred();\n        // A map from each write's document path to its corresponding result.\n        // Only contains writes that have not been resolved.\n        this.pendingOps = new Map();\n        this.backoff = new backoff_1.ExponentialBackoff();\n    }\n    /**\n     * The number of writes in this batch.\n     */\n    get opCount() {\n        return this.pendingOps.size;\n    }\n    /**\n     * Adds a `create` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n    create(documentRef, data) {\n        this.writeBatch.create(documentRef, data);\n        return this.processOperation(documentRef);\n    }\n    /**\n     * Adds a `delete` operation to the WriteBatch. Returns a promise that\n     * resolves with the sentinel value (Timestamp(0)) for the delete operation.\n     */\n    delete(documentRef, precondition) {\n        this.writeBatch.delete(documentRef, precondition);\n        return this.processOperation(documentRef);\n    }\n    /**\n     * Adds a `set` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n    set(documentRef, data, options) {\n        this.writeBatch.set(documentRef, data, options);\n        return this.processOperation(documentRef);\n    }\n    /**\n     * Adds an `update` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        this.writeBatch.update(documentRef, dataOrField, ...preconditionOrValues);\n        return this.processOperation(documentRef);\n    }\n    /**\n     * Helper to update data structures associated with the operation and\n     * return the result.\n     */\n    processOperation(documentRef) {\n        assert(!this.pendingOps.has(documentRef.path), 'Batch should not contain writes to the same document');\n        assert(this.state === BatchState.OPEN, 'Batch should be OPEN when adding writes');\n        const deferred = new util_1.Deferred();\n        this.pendingOps.set(documentRef.path, deferred);\n        if (this.opCount === this.maxBatchSize) {\n            this.state = BatchState.READY_TO_SEND;\n        }\n        return deferred.promise.then(result => {\n            if (result.writeTime) {\n                return new write_batch_1.WriteResult(result.writeTime);\n            }\n            else {\n                throw result.status;\n            }\n        });\n    }\n    /**\n     * Commits the batch and returns a promise that resolves when all the writes\n     * in the batch have finished.\n     *\n     * If any writes in the batch fail with a retryable error, this method will\n     * retry the failed writes.\n     */\n    async bulkCommit() {\n        assert(this.state === BatchState.READY_TO_SEND, 'The batch should be marked as READY_TO_SEND before committing');\n        this.state = BatchState.SENT;\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        let results = [];\n        for (let attempt = 0; attempt < backoff_1.MAX_RETRY_ATTEMPTS; attempt++) {\n            await this.backoff.backoffAndWait();\n            try {\n                results = await this.writeBatch.bulkCommit();\n            }\n            catch (err) {\n                // Map the failure to each individual write's result.\n                results = [...this.pendingOps.keys()].map(path => {\n                    return { key: path, writeTime: null, status: util_1.wrapError(err, stack) };\n                });\n            }\n            this.processResults(results);\n            if (this.pendingOps.size > 0) {\n                logger_1.logger('BulkWriter.bulkCommit', null, `Current batch failed at retry #${attempt}. Num failures: ` +\n                    `${this.pendingOps.size}.`);\n                this.writeBatch = new write_batch_1.WriteBatch(this.firestore, this.writeBatch, [\n                    ...this.pendingOps.keys(),\n                ]);\n            }\n            else {\n                this.completedDeferred.resolve();\n                return;\n            }\n        }\n        this.failRemainingOperations(results);\n        this.completedDeferred.resolve();\n    }\n    /**\n     * Resolves the individual operations in the batch with the results.\n     */\n    processResults(results) {\n        for (const result of results) {\n            if (result.status.code === google_gax_1.Status.OK) {\n                this.pendingOps.get(result.key).resolve(result);\n                this.pendingOps.delete(result.key);\n            }\n            else if (!this.shouldRetry(result.status.code)) {\n                this.pendingOps.get(result.key).reject(result.status);\n                this.pendingOps.delete(result.key);\n            }\n        }\n    }\n    failRemainingOperations(results) {\n        for (const result of results) {\n            assert(result.status.code !== google_gax_1.Status.OK, 'Should not fail successful operation');\n            this.pendingOps.get(result.key).reject(result.status);\n            this.pendingOps.delete(result.key);\n        }\n    }\n    shouldRetry(code) {\n        const retryCodes = util_1.getRetryCodes('batchWrite');\n        return code !== undefined && retryCodes.includes(code);\n    }\n    hasPath(path) {\n        for (const [docPath] of this.pendingOps) {\n            if (docPath === path)\n                return true;\n        }\n        return false;\n    }\n    docPaths() {\n        return this.pendingOps.keys();\n    }\n    /**\n     * Returns a promise that resolves when the batch has been sent, and a\n     * response is received.\n     */\n    awaitBulkCommit() {\n        this.markReadyToSend();\n        return this.completedDeferred.promise;\n    }\n    markReadyToSend() {\n        if (this.state === BatchState.OPEN) {\n            this.state = BatchState.READY_TO_SEND;\n        }\n    }\n}\n/**\n * A Firestore BulkWriter than can be used to perform a large number of writes\n * in parallel. Writes to the same document will be executed sequentially.\n *\n * @class\n */\nclass BulkWriter {\n    constructor(firestore, enableThrottling) {\n        this.firestore = firestore;\n        /**\n         * The maximum number of writes that can be in a single batch.\n         */\n        this.maxBatchSize = MAX_BATCH_SIZE;\n        /**\n         * A queue of batches to be written.\n         */\n        this.batchQueue = [];\n        /**\n         * Whether this BulkWriter instance is closed. Once closed, it cannot be\n         * opened again.\n         */\n        this.closed = false;\n        this.firestore._incrementBulkWritersCount();\n        if (enableThrottling) {\n            this.rateLimiter = new rate_limiter_1.RateLimiter(STARTING_MAXIMUM_OPS_PER_SECOND, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS);\n        }\n        else {\n            this.rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n        }\n    }\n    /**\n     * Create a document with the provided data. This single operation will fail\n     * if a document exists at its location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {T} data The object to serialize as the document.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * bulkWriter\n     *  .create(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    create(documentRef, data) {\n        this.verifyNotClosed();\n        const bulkCommitBatch = this.getEligibleBatch(documentRef);\n        const resultPromise = bulkCommitBatch.create(documentRef, data);\n        this.sendReadyBatches();\n        return resultPromise;\n    }\n    /**\n     * Delete a document from the database.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the batch if the\n     * document doesn't exist or was last updated at a different time.\n     * @returns {Promise<WriteResult>} A promise that resolves with a sentinel\n     * Timestamp indicating that the delete was successful. Throws an error if\n     * the write fails.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .delete(documentRef)\n     *  .then(result => {\n     *    console.log('Successfully deleted document');\n     *  })\n     *  .catch(err => {\n     *    console.log('Delete failed with: ', err);\n     *  });\n     * });\n     */\n    delete(documentRef, precondition) {\n        this.verifyNotClosed();\n        const bulkCommitBatch = this.getEligibleBatch(documentRef);\n        const resultPromise = bulkCommitBatch.delete(documentRef, precondition);\n        this.sendReadyBatches();\n        return resultPromise;\n    }\n    /**\n     * Write to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document does not\n     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,\n     * the provided data can be merged into the existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call remain\n     * untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()\n     * only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * bulkWriter\n     *  .set(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    set(documentRef, data, options) {\n        this.verifyNotClosed();\n        const bulkCommitBatch = this.getEligibleBatch(documentRef);\n        const resultPromise = bulkCommitBatch.set(documentRef, data, options);\n        this.sendReadyBatches();\n        return resultPromise;\n    }\n    /**\n     * Update fields of the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document doesn't yet\n     * exist, the update fails and the entire batch will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n     * fields and values with which to update the document or the path of the\n     * first field to update.\n     * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An\n     * alternating list of field paths and values to update or a Precondition to\n     * restrict this update\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .update(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        this.verifyNotClosed();\n        const bulkCommitBatch = this.getEligibleBatch(documentRef);\n        const resultPromise = bulkCommitBatch.update(documentRef, dataOrField, ...preconditionOrValues);\n        this.sendReadyBatches();\n        return resultPromise;\n    }\n    /**\n     * Commits all writes that have been enqueued up to this point in parallel.\n     *\n     * Returns a Promise that resolves when all currently queued operations have\n     * been committed. The Promise will never be rejected since the results for\n     * each individual operation are conveyed via their individual Promises.\n     *\n     * The Promise resolves immediately if there are no pending writes. Otherwise,\n     * the Promise waits for all previously issued writes, but it does not wait\n     * for writes that were added after the method is called. If you want to wait\n     * for additional writes, call `flush()` again.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await flush().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n    async flush() {\n        this.verifyNotClosed();\n        const trackedBatches = this.batchQueue;\n        const writePromises = trackedBatches.map(batch => batch.awaitBulkCommit());\n        this.sendReadyBatches();\n        await Promise.all(writePromises);\n    }\n    /**\n     * Commits all enqueued writes and marks the BulkWriter instance as closed.\n     *\n     * After calling `close()`, calling any method wil throw an error.\n     *\n     * Returns a Promise that resolves when there are no more pending writes. The\n     * Promise will never be rejected. Calling this method will send all requests.\n     * The promise resolves immediately if there are no pending writes.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await close().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n    close() {\n        this.verifyNotClosed();\n        this.firestore._decrementBulkWritersCount();\n        const flushPromise = this.flush();\n        this.closed = true;\n        return flushPromise;\n    }\n    verifyNotClosed() {\n        if (this.closed) {\n            throw new Error('BulkWriter has already been closed.');\n        }\n    }\n    /**\n     * Return the first eligible batch that can hold a write to the provided\n     * reference, or creates one if no eligible batches are found.\n     *\n     * @private\n     */\n    getEligibleBatch(ref) {\n        if (this.batchQueue.length > 0) {\n            const lastBatch = this.batchQueue[this.batchQueue.length - 1];\n            if (lastBatch.state === BatchState.OPEN && !lastBatch.hasPath(ref.path)) {\n                return lastBatch;\n            }\n        }\n        return this.createNewBatch();\n    }\n    /**\n     * Creates a new batch and adds it to the BatchQueue. If there is already a\n     * batch enqueued, sends the batch after a new one is created.\n     *\n     * @private\n     */\n    createNewBatch() {\n        const newBatch = new BulkCommitBatch(this.firestore, this.firestore.batch(), this.maxBatchSize);\n        if (this.batchQueue.length > 0) {\n            this.batchQueue[this.batchQueue.length - 1].markReadyToSend();\n            this.sendReadyBatches();\n        }\n        this.batchQueue.push(newBatch);\n        return newBatch;\n    }\n    /**\n     * Attempts to send batches starting from the front of the BatchQueue until a\n     * batch cannot be sent.\n     *\n     * After a batch is complete, try sending batches again.\n     *\n     * @private\n     */\n    sendReadyBatches() {\n        const unsentBatches = this.batchQueue.filter(batch => batch.state === BatchState.READY_TO_SEND);\n        let index = 0;\n        while (index < unsentBatches.length &&\n            this.isBatchSendable(unsentBatches[index])) {\n            const batch = unsentBatches[index];\n            // Send the batch if it is under the rate limit, or schedule another\n            // attempt after the appropriate timeout.\n            const delayMs = this.rateLimiter.getNextRequestDelayMs(batch.opCount);\n            assert(delayMs !== -1, 'Batch size should be under capacity');\n            if (delayMs === 0) {\n                this.sendBatch(batch);\n            }\n            else {\n                backoff_1.delayExecution(() => this.sendReadyBatches(), delayMs);\n                break;\n            }\n            index++;\n        }\n    }\n    /**\n     * Sends the provided batch and processes the results. After the batch is\n     * committed, sends the next group of ready batches.\n     *\n     * @private\n     */\n    sendBatch(batch) {\n        const success = this.rateLimiter.tryMakeRequest(batch.opCount);\n        assert(success, 'Batch should be under rate limit to be sent.');\n        batch.bulkCommit().then(() => {\n            // Remove the batch from the BatchQueue after it has been processed.\n            const batchIndex = this.batchQueue.indexOf(batch);\n            assert(batchIndex !== -1, 'The batch should be in the BatchQueue');\n            this.batchQueue.splice(batchIndex, 1);\n            this.sendReadyBatches();\n        });\n    }\n    /**\n     * Checks that the provided batch is sendable. To be sendable, a batch must:\n     * (1) be marked as READY_TO_SEND\n     * (2) not write to references that are currently in flight\n     *\n     * @private\n     */\n    isBatchSendable(batch) {\n        if (batch.state !== BatchState.READY_TO_SEND) {\n            return false;\n        }\n        for (const path of batch.docPaths()) {\n            const isRefInFlight = this.batchQueue\n                .filter(batch => batch.state === BatchState.SENT)\n                .find(batch => batch.hasPath(path)) !== undefined;\n            if (isRefInFlight) {\n                // eslint-disable-next-line no-console\n                console.warn('[BulkWriter]', `Duplicate write to document \"${path}\" detected.`, 'Writing to the same document multiple times will slow down BulkWriter. ' +\n                    'Write to unique documents in order to maximize throughput.');\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Sets the maximum number of allowed operations in a batch.\n     *\n     * @private\n     */\n    // Visible for testing.\n    _setMaxBatchSize(size) {\n        this.maxBatchSize = size;\n    }\n}\nexports.BulkWriter = BulkWriter;\n//# sourceMappingURL=bulk-writer.js.map"]},"metadata":{},"sourceType":"script"}