{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\medium clone\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar assert = require(\"assert\");\n/**\n * A helper that uses the Token Bucket algorithm to rate limit the number of\n * operations that can be made in a second.\n *\n * Before a given request containing a number of operations can proceed,\n * RateLimiter determines doing so stays under the provided rate limits. It can\n * also determine how much time is required before a request can be made.\n *\n * RateLimiter can also implement a gradually increasing rate limit. This is\n * used to enforce the 500/50/5 rule\n * (https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic).\n *\n * @private\n */\n\n\nvar RateLimiter = /*#__PURE__*/function () {\n  /**\n   * @param initialCapacity Initial maximum number of operations per second.\n   * @param multiplier Rate by which to increase the capacity.\n   * @param multiplierMillis How often the capacity should increase in\n   * milliseconds.\n   * @param startTimeMillis The starting time in epoch milliseconds that the\n   * rate limit is based on. Used for testing the limiter.\n   */\n  function RateLimiter(initialCapacity, multiplier, multiplierMillis) {\n    var startTimeMillis = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Date.now();\n\n    _classCallCheck(this, RateLimiter);\n\n    this.initialCapacity = initialCapacity;\n    this.multiplier = multiplier;\n    this.multiplierMillis = multiplierMillis;\n    this.startTimeMillis = startTimeMillis;\n    this.availableTokens = initialCapacity;\n    this.lastRefillTimeMillis = startTimeMillis;\n  }\n  /**\n   * Tries to make the number of operations. Returns true if the request\n   * succeeded and false otherwise.\n   *\n   * @param requestTimeMillis The time used to calculate the number of available\n   * tokens. Used for testing the limiter.\n   * @private\n   */\n\n\n  _createClass(RateLimiter, [{\n    key: \"tryMakeRequest\",\n    value: function tryMakeRequest(numOperations) {\n      var requestTimeMillis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Date.now();\n      this.refillTokens(requestTimeMillis);\n\n      if (numOperations <= this.availableTokens) {\n        this.availableTokens -= numOperations;\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Returns the number of ms needed to make a request with the provided number\n     * of operations. Returns 0 if the request can be made with the existing\n     * capacity. Returns -1 if the request is not possible with the current\n     * capacity.\n     *\n     * @param requestTimeMillis The time used to calculate the number of available\n     * tokens. Used for testing the limiter.\n     * @private\n     */\n\n  }, {\n    key: \"getNextRequestDelayMs\",\n    value: function getNextRequestDelayMs(numOperations) {\n      var requestTimeMillis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Date.now();\n      this.refillTokens(requestTimeMillis);\n\n      if (numOperations < this.availableTokens) {\n        return 0;\n      }\n\n      var capacity = this.calculateCapacity(requestTimeMillis);\n\n      if (capacity < numOperations) {\n        return -1;\n      }\n\n      var requiredTokens = numOperations - this.availableTokens;\n      return Math.ceil(requiredTokens * 1000 / capacity);\n    }\n    /**\n     * Refills the number of available tokens based on how much time has elapsed\n     * since the last time the tokens were refilled.\n     *\n     * @param requestTimeMillis The time used to calculate the number of available\n     * tokens. Used for testing the limiter.\n     * @private\n     */\n\n  }, {\n    key: \"refillTokens\",\n    value: function refillTokens(requestTimeMillis) {\n      if (requestTimeMillis >= this.lastRefillTimeMillis) {\n        var elapsedTime = requestTimeMillis - this.lastRefillTimeMillis;\n        var capacity = this.calculateCapacity(requestTimeMillis);\n        var tokensToAdd = Math.floor(elapsedTime * capacity / 1000);\n\n        if (tokensToAdd > 0) {\n          this.availableTokens = Math.min(capacity, this.availableTokens + tokensToAdd);\n          this.lastRefillTimeMillis = requestTimeMillis;\n        }\n      } else {\n        throw new Error('Request time should not be before the last token refill time.');\n      }\n    }\n    /**\n     * Calculates the maximum capacity based on the provided date.\n     *\n     * @private\n     */\n    // Visible for testing.\n\n  }, {\n    key: \"calculateCapacity\",\n    value: function calculateCapacity(requestTimeMillis) {\n      assert(requestTimeMillis >= this.startTimeMillis, 'startTime cannot be after currentTime');\n      var millisElapsed = requestTimeMillis - this.startTimeMillis;\n      var operationsPerSecond = Math.floor(Math.pow(this.multiplier, Math.floor(millisElapsed / this.multiplierMillis)) * this.initialCapacity);\n      return operationsPerSecond;\n    }\n  }]);\n\n  return RateLimiter;\n}();\n\nexports.RateLimiter = RateLimiter;","map":{"version":3,"sources":["D:/medium clone/node_modules/@google-cloud/firestore/build/src/rate-limiter.js"],"names":["Object","defineProperty","exports","value","assert","require","RateLimiter","initialCapacity","multiplier","multiplierMillis","startTimeMillis","Date","now","availableTokens","lastRefillTimeMillis","numOperations","requestTimeMillis","refillTokens","capacity","calculateCapacity","requiredTokens","Math","ceil","elapsedTime","tokensToAdd","floor","min","Error","millisElapsed","operationsPerSecond","pow"],"mappings":"AAAA;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACA;;;;;;;;;;;;;;;;AAeA,IAAMC,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;AACA;;;;;;;;;;;;;;;;IAcMC,W;AACF;;;;;;;;AAQA,uBAAYC,eAAZ,EAA6BC,UAA7B,EAAyCC,gBAAzC,EAAyF;AAAA,QAA9BC,eAA8B,uEAAZC,IAAI,CAACC,GAAL,EAAY;;AAAA;;AACrF,SAAKL,eAAL,GAAuBA,eAAvB;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKC,gBAAL,GAAwBA,gBAAxB;AACA,SAAKC,eAAL,GAAuBA,eAAvB;AACA,SAAKG,eAAL,GAAuBN,eAAvB;AACA,SAAKO,oBAAL,GAA4BJ,eAA5B;AACH;AACD;;;;;;;;;;;;mCAQeK,a,EAA+C;AAAA,UAAhCC,iBAAgC,uEAAZL,IAAI,CAACC,GAAL,EAAY;AAC1D,WAAKK,YAAL,CAAkBD,iBAAlB;;AACA,UAAID,aAAa,IAAI,KAAKF,eAA1B,EAA2C;AACvC,aAAKA,eAAL,IAAwBE,aAAxB;AACA,eAAO,IAAP;AACH;;AACD,aAAO,KAAP;AACH;AACD;;;;;;;;;;;;;0CAUsBA,a,EAA+C;AAAA,UAAhCC,iBAAgC,uEAAZL,IAAI,CAACC,GAAL,EAAY;AACjE,WAAKK,YAAL,CAAkBD,iBAAlB;;AACA,UAAID,aAAa,GAAG,KAAKF,eAAzB,EAA0C;AACtC,eAAO,CAAP;AACH;;AACD,UAAMK,QAAQ,GAAG,KAAKC,iBAAL,CAAuBH,iBAAvB,CAAjB;;AACA,UAAIE,QAAQ,GAAGH,aAAf,EAA8B;AAC1B,eAAO,CAAC,CAAR;AACH;;AACD,UAAMK,cAAc,GAAGL,aAAa,GAAG,KAAKF,eAA5C;AACA,aAAOQ,IAAI,CAACC,IAAL,CAAWF,cAAc,GAAG,IAAlB,GAA0BF,QAApC,CAAP;AACH;AACD;;;;;;;;;;;iCAQaF,iB,EAAmB;AAC5B,UAAIA,iBAAiB,IAAI,KAAKF,oBAA9B,EAAoD;AAChD,YAAMS,WAAW,GAAGP,iBAAiB,GAAG,KAAKF,oBAA7C;AACA,YAAMI,QAAQ,GAAG,KAAKC,iBAAL,CAAuBH,iBAAvB,CAAjB;AACA,YAAMQ,WAAW,GAAGH,IAAI,CAACI,KAAL,CAAYF,WAAW,GAAGL,QAAf,GAA2B,IAAtC,CAApB;;AACA,YAAIM,WAAW,GAAG,CAAlB,EAAqB;AACjB,eAAKX,eAAL,GAAuBQ,IAAI,CAACK,GAAL,CAASR,QAAT,EAAmB,KAAKL,eAAL,GAAuBW,WAA1C,CAAvB;AACA,eAAKV,oBAAL,GAA4BE,iBAA5B;AACH;AACJ,OARD,MASK;AACD,cAAM,IAAIW,KAAJ,CAAU,+DAAV,CAAN;AACH;AACJ;AACD;;;;;AAKA;;;;sCACkBX,iB,EAAmB;AACjCZ,MAAAA,MAAM,CAACY,iBAAiB,IAAI,KAAKN,eAA3B,EAA4C,uCAA5C,CAAN;AACA,UAAMkB,aAAa,GAAGZ,iBAAiB,GAAG,KAAKN,eAA/C;AACA,UAAMmB,mBAAmB,GAAGR,IAAI,CAACI,KAAL,CAAWJ,IAAI,CAACS,GAAL,CAAS,KAAKtB,UAAd,EAA0Ba,IAAI,CAACI,KAAL,CAAWG,aAAa,GAAG,KAAKnB,gBAAhC,CAA1B,IAA+E,KAAKF,eAA/F,CAA5B;AACA,aAAOsB,mBAAP;AACH;;;;;;AAEL3B,OAAO,CAACI,WAAR,GAAsBA,WAAtB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*!\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst assert = require(\"assert\");\n/**\n * A helper that uses the Token Bucket algorithm to rate limit the number of\n * operations that can be made in a second.\n *\n * Before a given request containing a number of operations can proceed,\n * RateLimiter determines doing so stays under the provided rate limits. It can\n * also determine how much time is required before a request can be made.\n *\n * RateLimiter can also implement a gradually increasing rate limit. This is\n * used to enforce the 500/50/5 rule\n * (https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic).\n *\n * @private\n */\nclass RateLimiter {\n    /**\n     * @param initialCapacity Initial maximum number of operations per second.\n     * @param multiplier Rate by which to increase the capacity.\n     * @param multiplierMillis How often the capacity should increase in\n     * milliseconds.\n     * @param startTimeMillis The starting time in epoch milliseconds that the\n     * rate limit is based on. Used for testing the limiter.\n     */\n    constructor(initialCapacity, multiplier, multiplierMillis, startTimeMillis = Date.now()) {\n        this.initialCapacity = initialCapacity;\n        this.multiplier = multiplier;\n        this.multiplierMillis = multiplierMillis;\n        this.startTimeMillis = startTimeMillis;\n        this.availableTokens = initialCapacity;\n        this.lastRefillTimeMillis = startTimeMillis;\n    }\n    /**\n     * Tries to make the number of operations. Returns true if the request\n     * succeeded and false otherwise.\n     *\n     * @param requestTimeMillis The time used to calculate the number of available\n     * tokens. Used for testing the limiter.\n     * @private\n     */\n    tryMakeRequest(numOperations, requestTimeMillis = Date.now()) {\n        this.refillTokens(requestTimeMillis);\n        if (numOperations <= this.availableTokens) {\n            this.availableTokens -= numOperations;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Returns the number of ms needed to make a request with the provided number\n     * of operations. Returns 0 if the request can be made with the existing\n     * capacity. Returns -1 if the request is not possible with the current\n     * capacity.\n     *\n     * @param requestTimeMillis The time used to calculate the number of available\n     * tokens. Used for testing the limiter.\n     * @private\n     */\n    getNextRequestDelayMs(numOperations, requestTimeMillis = Date.now()) {\n        this.refillTokens(requestTimeMillis);\n        if (numOperations < this.availableTokens) {\n            return 0;\n        }\n        const capacity = this.calculateCapacity(requestTimeMillis);\n        if (capacity < numOperations) {\n            return -1;\n        }\n        const requiredTokens = numOperations - this.availableTokens;\n        return Math.ceil((requiredTokens * 1000) / capacity);\n    }\n    /**\n     * Refills the number of available tokens based on how much time has elapsed\n     * since the last time the tokens were refilled.\n     *\n     * @param requestTimeMillis The time used to calculate the number of available\n     * tokens. Used for testing the limiter.\n     * @private\n     */\n    refillTokens(requestTimeMillis) {\n        if (requestTimeMillis >= this.lastRefillTimeMillis) {\n            const elapsedTime = requestTimeMillis - this.lastRefillTimeMillis;\n            const capacity = this.calculateCapacity(requestTimeMillis);\n            const tokensToAdd = Math.floor((elapsedTime * capacity) / 1000);\n            if (tokensToAdd > 0) {\n                this.availableTokens = Math.min(capacity, this.availableTokens + tokensToAdd);\n                this.lastRefillTimeMillis = requestTimeMillis;\n            }\n        }\n        else {\n            throw new Error('Request time should not be before the last token refill time.');\n        }\n    }\n    /**\n     * Calculates the maximum capacity based on the provided date.\n     *\n     * @private\n     */\n    // Visible for testing.\n    calculateCapacity(requestTimeMillis) {\n        assert(requestTimeMillis >= this.startTimeMillis, 'startTime cannot be after currentTime');\n        const millisElapsed = requestTimeMillis - this.startTimeMillis;\n        const operationsPerSecond = Math.floor(Math.pow(this.multiplier, Math.floor(millisElapsed / this.multiplierMillis)) * this.initialCapacity);\n        return operationsPerSecond;\n    }\n}\nexports.RateLimiter = RateLimiter;\n//# sourceMappingURL=rate-limiter.js.map"]},"metadata":{},"sourceType":"script"}